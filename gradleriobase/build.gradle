import org.gradle.internal.component.external.model.DefaultModuleComponentIdentifier
import jaci.gradle.nativedeps.NativeDepsSpec
import com.google.gson.GsonBuilder

buildscript {
    dependencies {
        classpath 'com.google.code.gson:gson:2.2.4'
    }
}


plugins {
    id "java"
    id 'cpp'
    id "edu.wpi.first.GradleRIO" version "2019.0.0-beta0-pre1"
}

wpi {
    shuffleboardVersion = '1.3.1-20180822155514-46-g853ce2d'
    outlineViewerVersion = '2.0.7-20180701134809'
    robotBuilderVersion = '3.0.1-20180701134409-1-gf70dcba'
    smartDashboardVersion = '3.0.1-20180701135609'
}


// Defining my dependencies. In this case, WPILib (+ friends), CTRE Toolsuite (Talon SRX)
// and NavX.
dependencies {
    compile wpilib()
}

model {
    components {
        frcUserProgram(NativeExecutableSpec) {
            targetPlatform 'roborio'
            targetPlatform 'desktop'

            // Defining my dependencies. In this case, WPILib (+ friends), CTRE Toolsuite (Talon SRX)
            // and NavX.
            useLibrary(it, "wpilib", "googletest")
        }
    }
}

class WPIDepsGrabber implements Plugin<Project> {
    void apply(Project project) {

    }

    static class WPIDepGrabberRules extends RuleSource {

        @Mutate
        void triggerDeps(ModelMap<Task> tasks, NativeDepsSpec deps) {
            System.out.println('Model triggered')
        }
    }
}

apply plugin: WPIDepsGrabber

tasks.register('modelEvaluationTrigger') {

}

def getConfig = { configs, deps->
    configs.each { config->
        println config
        if (config.canBeResolved) {
            config.resolvedConfiguration.resolvedArtifacts.each {
                def item = [:];
                item['classifier'] = it.classifier
                item['extension'] = it.extension
                def id = it.moduleVersion.id
                item['groupId'] = id.group
                item['version'] = id.version
                item['artifactId'] = id.name
                deps << item
            }
            def componentIds = config.incoming.resolutionResult.allDependencies.collect { it.selected.id }
            def result = dependencies.createArtifactResolutionQuery()
                                     .forComponents(componentIds)
                                     .withArtifacts(JvmLibrary, SourcesArtifact, JavadocArtifact)
                                     .execute()

            for (component in result.resolvedComponents) {
                component.getArtifacts(SourcesArtifact).each {

                    def item = [:];
                    item['classifier'] = 'sources'
                    item['extension'] = 'jar'
                    def id = it.id.componentIdentifier
                    item['groupId'] = id.group
                    item['version'] = id.version
                    item['artifactId'] = id.module
                    deps << item

                }
                component.getArtifacts(JavadocArtifact).each {
                                        def item = [:];
                    item['classifier'] = 'javadoc'
                    item['extension'] = 'jar'
                    def id = it.id.componentIdentifier
                    item['groupId'] = id.group
                    item['version'] = id.version
                    item['artifactId'] = id.module
                    deps << item
                }
            }
        }
    }
}

repositories {
    gradlePluginPortal()
}

ext.getGradleRioUrls = {
    Set urls = [];

    repositories.each {
        urls << it.url
    }

    return urls
}

ext.getGradleRioDependencies = {
    def output = [:]
    Set deps = []

    getConfig(configurations, deps)
    getConfig(buildscript.configurations, deps)

    output['deps'] = deps

    return output
}
